<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>存储器层次结构及cache映射方式</title>
      <link href="/2025/03/28/cache-map/"/>
      <url>/2025/03/28/cache-map/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机体系结构-存储器层次结构及cache映射方式"><a href="#计算机体系结构-存储器层次结构及cache映射方式" class="headerlink" title="[计算机体系结构] 存储器层次结构及cache映射方式"></a>[计算机体系结构] 存储器层次结构及cache映射方式</h1><blockquote><p>计算机中有多种不同的存储技术，不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高但容量较小且价格更贵，容量较大的存储技术速度较慢。而一个良好的计算机程序往往需要良好的局部性，包括空间局部性和时间局部性。为了使软件和硬件的这些基本属性相互补充，计算机系统使用一种组织存储器系统的方法，称为存储器层次结构。高速缓存（cache）就在其中扮演着重要的角色，本文将介绍cache的三种映射方式。</p></blockquote><h2 id="1-存储器层次结构简介"><a href="#1-存储器层次结构简介" class="headerlink" title="1.存储器层次结构简介"></a>1.存储器层次结构简介</h2><p>下图展示了一个典型的存储器层次结构。一般而言，从高层到底层，存储设备变得更慢、更便宜和更大。在最高层是少量快速的CPU寄存器，CPU可以在一个时钟周期内访问它们。接下来是一个或多个小型到中型的基于SRAM的高速缓存存储器，然后是一个大的基于DRAM的主存。最后是慢速但是容量很大的外部存储器和后备存储器。可以看出CPU的访问时间依次增大。</p><p><a href="https://imgse.com/i/pErR3tO"><img src="https://s21.ax1x.com/2025/03/29/pErR3tO.png" alt="pErR3tO.png"></a></p><p>存储器层次结构的中心思想是，层次结构中的每一层都缓存来自较低一层的数据对象。例如，主存作为本地磁盘上数据的缓存，高速缓存寄存器作为主存数据的缓存，以此类推。</p><p>下图展示了存储器层次结构中缓存的工作原理。第k+1层的存储器被划分成连续的数据对象组块，称为块(block).<strong>请注意，数据是以块为传送单元在层与层之间传输的。</strong>例如，假如块大小为64字节，即使上层只需要某一字节的数据，下层仍然会把块中的64字节的数据都传输上去而不仅仅只传输该字节。这种机制目的是利用局部性原理来提升效率。</p><p><a href="https://imgse.com/i/pErRNjA"><img src="https://s21.ax1x.com/2025/03/29/pErRNjA.png" alt="pErRNjA.png"></a></p><h2 id="2-存储器层次结构中的缓存"><a href="#2-存储器层次结构中的缓存" class="headerlink" title="2.存储器层次结构中的缓存"></a>2.存储器层次结构中的缓存</h2><p>高速缓存(cache, 读作“cash”)是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。</p><h3 id="2-1缓存命中（Hit）"><a href="#2-1缓存命中（Hit）" class="headerlink" title="2.1缓存命中（Hit）"></a>2.1缓存命中（Hit）</h3><p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层中査找。如果d刚好位于第k层中，那么就是我们所说的<strong>缓存命中</strong>（cache hit） 该程序直接从第k层读取。</p><h3 id="2-2缓存不命中（Miss）"><a href="#2-2缓存不命中（Miss）" class="headerlink" title="2.2缓存不命中（Miss）"></a>2.2缓存不命中（Miss）</h3><p>如果第k层中没有缓存数据对象，那么就是我们所说的<strong>缓存不命中</strong> (cache miss)，当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了可能就会覆盖现存的一个块。</p><h3 id="2-3缓存不命中的种类"><a href="#2-3缓存不命中的种类" class="headerlink" title="2.3缓存不命中的种类"></a>2.3缓存不命中的种类</h3><p><strong>强制性不命中（compulsory miss）</strong>：如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。只要数据是第一次被读取或写入，就一定会发生不命中，这是由缓存的工作原理决定的。强制性不命中通常是短暂的事件，不会在反复访问存储器使得缓存暖身（wanned up）之后的稳定状态中出现。</p><p><strong>冲突不命中（conflict miss）</strong>：不同的数据块被映射到同一个缓存行（Cache Line）的位置，导致缓存频繁替换，即使缓存总容量足够，仍然因地址冲突而引发未命中。冲突不命中的核心原因是缓存映射策略的限制，尤其是组相联或直接映射缓存会出现该种情况。</p><h2 id="3-高速缓存存储器三种映射方式"><a href="#3-高速缓存存储器三种映射方式" class="headerlink" title="3.高速缓存存储器三种映射方式"></a>3.高速缓存存储器三种映射方式</h2><p>高速缓存的映射是指 <strong>如何将主存中的数据块放置到高速缓存（Cache）中的规则和方法</strong>。即需要从主存中提取数据时，建立什么样的方法将主存中的块放到Cache中的哪个位置。它决定了<strong>主存地址</strong>与<strong>缓存位置</strong>之间的对应关系，直接影响缓存的命中率、访问速度和硬件复杂度。</p><h3 id="3-1直接映射高速缓存"><a href="#3-1直接映射高速缓存" class="headerlink" title="3.1直接映射高速缓存"></a>3.1直接映射高速缓存</h3><p>直接映射高速缓存是缓存设计中最简单的一种方式，在cache中每一组只有一行，其核心特点是 <strong>每个主存块只能映射到缓存中唯一固定的位置</strong>。它的设计目标是 <strong>以最低硬件复杂度实现快速查找</strong>，但可能因地址冲突导致较高的冲突不命中。每个主存块所属的cache行是 <strong>主存块号 % cache总行数</strong>。</p><p><a href="https://imgse.com/i/pErRtcd"><img src="https://s21.ax1x.com/2025/03/29/pErRtcd.png" alt="pErRtcd.png"></a></p><p>主存地址被分为三部分：标记（Tag）、组索引（Index）、块偏移（Block Offset）。高速缓存从主存地址中间抽取出s个组索引位。如果把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。在图片的例子中，组索引位00001被解释为一个选择组1的整数索引。</p><p><a href="https://imgse.com/i/pErRdBt"><img src="https://s21.ax1x.com/2025/03/29/pErRdBt.png" alt="pErRdBt.png"></a></p><p>选择了某个组后，就要确定该组中是否含有副本存储在cache中。这在直接映射高速缓存中很容易实现，因为每个组只有<strong>一行</strong>。假如这一组中的这一行设置了有效位，且其标志位与主存地址标记相等，那么这一行中包含了其副本。相反，假如有效位为0或者标记位不相等，那么缓存不命中。当缓存命中后，利用块偏移定位行内的数据，用于在缓存块中精确找到所需数据。</p><h3 id="3-2组相联高速缓存"><a href="#3-2组相联高速缓存" class="headerlink" title="3.2组相联高速缓存"></a>3.2组相联高速缓存</h3><p>由于每个主存块只能映射到缓存中唯一固定的位置，会经常造成冲突不命中，这是因为每一组只有一行。假如在同一组中有多行，cache就能保存着多行的数据，减少不命中的几率。直接映射可以看作1路组相联。下图中一个组含有两行，称为2路组相联。</p><p><a href="https://imgse.com/i/pErRtcd"><img src="https://s21.ax1x.com/2025/03/29/pErRtcd.png" alt="pErRtcd.png"></a></p><p>它的组选择与直接映射高速缓存的组选择一样，组索引位决定了位于哪个组。但由于一个组中有多个行，所以在行选择中必须检查组中多个行的标记位和有效位，以确定所请求的字是否在集合中。由于主存中的块可以映射到某一个组中任意一行，所以高速缓存必须搜索组中的每一行， 当且找到了某一行有效位为1且其标记与地址中的标记相匹配，那么判定为命中，块偏移从这个块中选择一个字，和前面一样。</p><p>如果CPU请求的字不在组的任何一行中，那么就是缓存不命中，这时需要从内存中取出包含这个字的块。不过，一旦取出了这个块该替换组内的哪个行呢？一般有两种策略，一个是最不常使用（LFU）会替换在过去某个时间窗口内引用次数最少的那一行，另一个是最近最少使用（LRU）会替换最后一次访问时间最久远的那一行。此外还有先进先出替换（FIFO）等。</p><h3 id="3-3全相联高速缓存"><a href="#3-3全相联高速缓存" class="headerlink" title="3.3全相联高速缓存"></a>3.3全相联高速缓存</h3><p>全相联高速缓存是由一个包含所有高速缓存行的组，全相联高速缓存中的组选择非常简单，因为只有一个组，主存中所有的块都会被映射到同一个组中。</p><p><a href="https://imgse.com/i/pErR8hD"><img src="https://s21.ax1x.com/2025/03/29/pErR8hD.png" alt="pErR8hD.png"></a></p><p>由于全相联只有一组，所以主存地址仅划分为标记位和块偏移，没有组索引位。其行匹配与字选择与上述方式类似。下图为详细的步骤。</p><p><a href="https://imgse.com/i/pErRanI"><img src="https://s21.ax1x.com/2025/03/29/pErRanI.png" alt="pErRanI.png"></a></p><h2 id="4-三种映射方式的计算"><a href="#4-三种映射方式的计算" class="headerlink" title="4.三种映射方式的计算"></a>4.三种映射方式的计算</h2><p><del>写这篇文章其实不是为了介绍三种方式的，而是为了复习三种映射方式的计算（，由于作者比较蠢笨，在计算机组成和计算机系统原理这两门课学习了两次后仍然对计算不太了解，做实验时总是被计算困扰，所以一气之下复习了一遍并写了这篇文章…</del></p><p>几个重要的公式：</p><ul><li>cache大小 &#x3D; cache块数 x cache每块大小</li><li>组索引 &#x3D; log2（cache块数）</li><li>块内地址（块偏移量）&#x3D; log2（cache每块大小）</li><li>主存地址长度 &#x3D; log2（主存中存储单元个数）</li><li>cache地址长度 &#x3D;  log2（Cache中存储单元个数）</li><li>1字节(Byte) &#x3D; 8比特(bit)    </li><li>1KB &#x3D; $2^10$B</li></ul><p><a href="https://imgse.com/i/pErRJ9e"><img src="https://s21.ax1x.com/2025/03/29/pErRJ9e.png" alt="pErRJ9e.png"></a></p><p>参考文献</p><blockquote><p>《深入理解计算机系统》Randal E.Bryant,David R.O’Hallaron;third edition</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！This is test blog</title>
      <link href="/2025/01/17/hello-world/"/>
      <url>/2025/01/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
